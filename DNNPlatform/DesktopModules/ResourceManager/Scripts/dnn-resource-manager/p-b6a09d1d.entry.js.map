{"version":3,"sources":["../../../../node_modules/@dnncommunity/dnn-elements/dist/collection/components/dnn-image-cropper/CornerType.js","../../../../node_modules/@dnncommunity/dnn-elements/dist/collection/components/dnn-image-cropper/dnn-image-cropper.css?tag=dnn-image-cropper&encapsulation=shadow","../../../../node_modules/@dnncommunity/dnn-elements/dist/collection/components/dnn-image-cropper/dnn-image-cropper.js"],"names":["CornerType","dnnImageCropperCss","DnnImageCropper","[object Object]","hostRef","this","width","height","resx","capture","dragAndDropFile","or","takePicture","uploadFile","imageTooSmall","modalCloseText","quality","preventUndersized","handleCropMouseDown","event","stopPropagation","preventDefault","element","target","className","classList","document","addEventListener","handleImageCropFinished","handleCropDrag","removeEventListener","handleNwMouseMove","handleNeMouseMove","handleSeMouseMove","handleSwMouseMove","_ev","emitImage","previousTouch","undefined","handleCornerDrag","nw","ne","se","sw","corner","isMouseStillInTarget","left","top","getCornerLeftTop","newWidth","newHeight","orientation","wantedRatio","cropRect","crop","getBoundingClientRect","imageRect","image","movementX","movementY","getMovementFromEvent","Math","abs","topOffset","offsetTop","leftOffset","offsetLeft","zoomRatio","naturalWidth","style","ev","newLeft","newTop","requestAnimationFrame","setView","newView","views","host","shadowRoot","querySelectorAll","forEach","v","remove","noPictureView","add","hasPictureView","view","imageRatio","wantedHeight","diff","round","toString","wantedWidth","initCrop","src","canvas","toDataURL","file","type","split","reader","FileReader","onload","readerLoadEvent","img","Image","imageTooSmallModal","show","ctx","getContext","drawImage","setImage","result","readAsDataURL","x","y","naturalHeight","dataUrl","generateCroppedImage","imageCropChanged","emit","desiredWidth","desiredHeight","context","clearRect","inside","mouseX","mouseY","MouseEvent","clientX","clientY","TouchEvent","touch","touches","corners","cornerRect","h","Host","ref","el","class","e","onMouseDown","onTouchStart","allowCameraMode","onFilesSelected","handleNewFile","detail","close-text","replace"],"mappings":"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","sourcesContent":["export var CornerType;\n(function (CornerType) {\n  CornerType[CornerType[\"nw\"] = 0] = \"nw\";\n  CornerType[CornerType[\"ne\"] = 1] = \"ne\";\n  CornerType[CornerType[\"se\"] = 2] = \"se\";\n  CornerType[CornerType[\"sw\"] = 3] = \"sw\";\n})(CornerType || (CornerType = {}));\n;\n//# sourceMappingURL=CornerType.js.map\n",":host {\n  display: block;\n}\n\ncanvas {\n  display: none;\n}\n\n.view {\n  visibility: hidden;\n  opacity: 0;\n  height: 0;\n  overflow: hidden;\n  transition: all 300ms ease-in-out;\n}\n.view.visible {\n  visibility: visible;\n  opacity: 1;\n  height: initial;\n  overflow: visible;\n}\n.view .cropper {\n  position: relative;\n  width: 100%;\n}\n.view .cropper img {\n  width: 100%;\n  display: block;\n  margin: 0 auto;\n}\n.view .cropper .backdrop {\n  backdrop-filter: saturate(0.5);\n  backdrop-filter: brightness(0.5);\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n}\n.view .cropper .crop {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  outline: 2px dashed white;\n  box-shadow: black 0 0 0px 2px;\n  backdrop-filter: saturate(2);\n  backdrop-filter: brightness(2);\n  cursor: move;\n}\n.view .cropper .crop > div {\n  width: 20px;\n  height: 20px;\n  background-color: white;\n  border: 2px solid rgba(0, 0, 0, 0.5);\n  position: absolute;\n}\n.view .cropper .crop > div.nw, .view .cropper .crop > div.ne {\n  top: -17px;\n}\n.view .cropper .crop > div.ne, .view .cropper .crop > div.se {\n  right: -17px;\n}\n.view .cropper .crop > div.se, .view .cropper .crop > div.sw {\n  bottom: -17px;\n}\n.view .cropper .crop > div.sw, .view .cropper .crop > div.nw {\n  left: -17px;\n}\n.view .cropper .crop > div.nw, .view .cropper .crop > div.se {\n  cursor: nwse-resize;\n}\n.view .cropper .crop > div.ne, .view .cropper .crop > div.sw {\n  cursor: nesw-resize;\n}\n\ndnn-modal {\n  --max-width: 512px;\n}","import { Host, h } from '@stencil/core';\nimport { CornerType } from './CornerType';\nimport { getMovementFromEvent } from \"../../utilities/mouseUtilities\";\n/**\n * Allows cropping an image in-browser with the option to enforce a specific final size.\n * All computation happens in the browser and the final image is emmited\n * in an event that has a data-url of the image.\n */\nexport class DnnImageCropper {\n  constructor() {\n    /** Sets the desired final image width. */\n    this.width = 600;\n    /** Sets the desired final image height. */\n    this.height = 600;\n    /** Can be used to customize controls text.\n     * Some values support tokens, see default values for examples.\n    */\n    this.resx = {\n      capture: \"Capture\",\n      dragAndDropFile: \"Drag and drop an image\",\n      or: \"or\",\n      takePicture: \"Take a picture\",\n      uploadFile: \"Upload an image\",\n      imageTooSmall: \"The image you are attempting to upload does not meet the minimum size requirement of {width} pixels by {height} pixels. Please upload a larger image.\",\n      modalCloseText: \"Close\",\n    };\n    /** Sets the output quality of the corpped image (number between 0 and 1). */\n    this.quality = 0.8;\n    /** When set to true, prevents cropping an image smaller than the required size, which would blow pixel and make the final picture look blurry. */\n    this.preventUndersized = false;\n    this.handleCropMouseDown = (event) => {\n      event.stopPropagation();\n      event.preventDefault();\n      const element = event.target;\n      const className = element.classList[0];\n      document.addEventListener(\"mouseup\", this.handleImageCropFinished, false);\n      document.addEventListener(\"touchend\", this.handleImageCropFinished, false);\n      switch (className) {\n        case \"crop\":\n          document.addEventListener(\"mousemove\", this.handleCropDrag, false);\n          document.addEventListener(\"touchmove\", this.handleCropDrag, false);\n          document.addEventListener(\"mouseup\", () => document.removeEventListener(\"mousemove\", this.handleCropDrag));\n          document.addEventListener(\"touchend\", () => document.removeEventListener(\"touchmove\", this.handleCropDrag));\n          break;\n        case \"nw\":\n          document.addEventListener(\"mousemove\", this.handleNwMouseMove, false);\n          document.addEventListener(\"touchmove\", this.handleNwMouseMove, false);\n          document.addEventListener(\"mouseup\", () => document.removeEventListener(\"mousemove\", this.handleNwMouseMove));\n          document.addEventListener(\"touchend\", () => document.removeEventListener(\"touchmove\", this.handleNwMouseMove));\n          break;\n        case \"ne\":\n          document.addEventListener(\"mousemove\", this.handleNeMouseMove, false);\n          document.addEventListener(\"touchmove\", this.handleNeMouseMove, false);\n          document.addEventListener(\"mouseup\", () => document.removeEventListener(\"mousemove\", this.handleNeMouseMove));\n          document.addEventListener(\"touchend\", () => document.removeEventListener(\"touchmove\", this.handleNeMouseMove));\n          break;\n        case \"se\":\n          document.addEventListener(\"mousemove\", this.handleSeMouseMove, false);\n          document.addEventListener(\"touchmove\", this.handleSeMouseMove, false);\n          document.addEventListener(\"mouseup\", () => document.removeEventListener(\"mousemove\", this.handleSeMouseMove));\n          document.addEventListener(\"touchend\", () => document.removeEventListener(\"touchmove\", this.handleSeMouseMove));\n          break;\n        case \"sw\":\n          document.addEventListener(\"mousemove\", this.handleSwMouseMove, false);\n          document.addEventListener(\"touchmove\", this.handleSwMouseMove, false);\n          document.addEventListener(\"mouseup\", () => document.removeEventListener(\"mousemove\", this.handleSwMouseMove));\n          document.addEventListener(\"touchend\", () => document.removeEventListener(\"touchmove\", this.handleSwMouseMove));\n          break;\n        default:\n          break;\n      }\n    };\n    this.handleImageCropFinished = (_ev) => {\n      this.emitImage();\n      document.removeEventListener(\"mouseup\", this.handleImageCropFinished);\n      this.previousTouch = undefined;\n    };\n    this.handleNwMouseMove = (event) => {\n      this.handleCornerDrag(event, CornerType.nw);\n    };\n    this.handleNeMouseMove = (event) => {\n      this.handleCornerDrag(event, CornerType.ne);\n    };\n    this.handleSeMouseMove = (event) => {\n      this.handleCornerDrag(event, CornerType.se);\n    };\n    this.handleSwMouseMove = (event) => {\n      this.handleCornerDrag(event, CornerType.sw);\n    };\n    this.handleCornerDrag = (event, corner) => {\n      if (!this.isMouseStillInTarget(event)) {\n        return;\n      }\n      let { left, top } = this.getCornerLeftTop(corner);\n      let newWidth = 0;\n      let newHeight = 0;\n      let orientation = \"horizontal\";\n      const wantedRatio = this.width / this.height;\n      const cropRect = this.crop.getBoundingClientRect();\n      const imageRect = this.image.getBoundingClientRect();\n      let { movementX, movementY } = getMovementFromEvent(event, this.previousTouch);\n      if (Math.abs(movementX) < Math.abs(movementY)) {\n        orientation = \"vertical\";\n      }\n      if (orientation == \"horizontal\") {\n        switch (corner) {\n          case CornerType.nw:\n          case CornerType.sw:\n            newWidth = cropRect.width - movementX;\n            newHeight = newWidth / wantedRatio;\n            break;\n          case CornerType.ne:\n          case CornerType.se:\n            newWidth = cropRect.width + movementX;\n            newHeight = newWidth / wantedRatio;\n            break;\n          default:\n            break;\n        }\n      }\n      else {\n        switch (corner) {\n          case CornerType.nw:\n          case CornerType.ne:\n            newHeight = cropRect.height - movementY;\n            newWidth = newHeight * wantedRatio;\n            break;\n          case CornerType.se:\n          case CornerType.sw:\n            newHeight = cropRect.height + movementY;\n            newWidth = newHeight * wantedRatio;\n            break;\n          default:\n            break;\n        }\n      }\n      switch (corner) {\n        case CornerType.ne:\n        case CornerType.nw:\n          const topOffset = cropRect.height - newHeight;\n          top = this.crop.offsetTop + topOffset;\n        default:\n          break;\n      }\n      switch (corner) {\n        case CornerType.nw:\n        case CornerType.sw:\n          const leftOffset = cropRect.width - newWidth;\n          left = this.crop.offsetLeft + leftOffset;\n          if (left < 0)\n            left = 0;\n          if (left > imageRect.width)\n            left = imageRect.width;\n          if (top < 0)\n            top = 0;\n          if (top > imageRect.height)\n            top = imageRect.height;\n          if (left + newWidth > imageRect.width)\n            newWidth = imageRect.width - left;\n          if (top + newHeight > imageRect.height)\n            newHeight = imageRect.height - top;\n          break;\n        case CornerType.ne:\n        case CornerType.se:\n          if (top < 0)\n            top = 0;\n          if (top > imageRect.height)\n            top = imageRect.height;\n          if (left + newWidth > imageRect.width)\n            newWidth = imageRect.width - left;\n          if (top + newHeight > imageRect.height)\n            newHeight = imageRect.height - top;\n          break;\n        default:\n          break;\n      }\n      if (newWidth / newHeight != wantedRatio) {\n        return;\n      }\n      if (this.preventUndersized) {\n        const zoomRatio = this.image.width / this.image.naturalWidth;\n        if (newWidth / zoomRatio < this.width || newHeight / zoomRatio < this.height) {\n          return;\n        }\n      }\n      switch (corner) {\n        case CornerType.ne:\n          this.crop.style.top = `${top}px`;\n          this.crop.style.width = `${newWidth}px`;\n          this.crop.style.height = `${newHeight}px`;\n          break;\n        case CornerType.nw:\n          this.crop.style.left = `${left}px`;\n          this.crop.style.top = `${top}px`;\n          this.crop.style.width = `${newWidth}px`;\n          this.crop.style.height = `${newHeight}px`;\n          break;\n        case CornerType.se:\n          this.crop.style.width = `${newWidth}px`;\n          this.crop.style.height = `${newHeight}px`;\n          break;\n        case CornerType.sw:\n          this.crop.style.left = `${left}px`;\n          this.crop.style.width = `${newWidth}px`;\n          this.crop.style.height = `${newHeight}px`;\n          break;\n        default:\n          break;\n      }\n    };\n    this.handleCropDrag = (ev) => {\n      if (!this.isMouseStillInTarget(ev)) {\n        return;\n      }\n      let { movementX, movementY } = getMovementFromEvent(ev, this.previousTouch);\n      let newLeft = this.crop.offsetLeft + movementX;\n      let newTop = this.crop.offsetTop + movementY;\n      var imageRect = this.image.getBoundingClientRect();\n      var cropRect = this.crop.getBoundingClientRect();\n      if (newLeft < 0) {\n        newLeft = 0;\n      }\n      if (newTop < 0) {\n        newTop = 0;\n      }\n      if (newLeft + cropRect.width > imageRect.width) {\n        newLeft = this.crop.offsetLeft;\n      }\n      if (newTop + cropRect.height > imageRect.height) {\n        newTop = this.crop.offsetTop;\n      }\n      this.crop.style.left = newLeft + \"px\";\n      this.crop.style.top = newTop + \"px\";\n    };\n  }\n  componentDidLoad() {\n    requestAnimationFrame(() => {\n      this.setView(\"noPictureView\");\n    });\n  }\n  setView(newView) {\n    const views = this.host.shadowRoot.querySelectorAll(\".view\");\n    views.forEach(v => v.classList.remove(\"visible\"));\n    switch (newView) {\n      case \"noPictureView\":\n        this.noPictureView.classList.add(\"visible\");\n        break;\n      case \"hasPictureView\":\n        this.hasPictureView.classList.add(\"visible\");\n        break;\n      default:\n        break;\n    }\n    this.view = newView;\n  }\n  initCrop() {\n    var wantedRatio = this.width / this.height;\n    var imageRect = this.image.getBoundingClientRect();\n    var imageRatio = imageRect.width / imageRect.height;\n    if (wantedRatio > imageRatio) {\n      var wantedHeight = imageRect.width / wantedRatio;\n      var diff = imageRect.height - wantedHeight;\n      this.crop.style.top = Math.round(diff / 2).toString() + \"px\";\n      this.crop.style.height = Math.round(wantedHeight).toString() + \"px\";\n    }\n    else {\n      var wantedWidth = imageRect.height * wantedRatio;\n      var diff = imageRect.width - wantedWidth;\n      this.crop.style.left = Math.round(diff / 2).toString() + \"px\";\n      this.crop.style.width = Math.round(wantedWidth).toString() + \"px\";\n    }\n  }\n  setImage() {\n    this.image.addEventListener('load', () => {\n      this.initCrop();\n      this.emitImage();\n    });\n    this.image.src = this.canvas.toDataURL();\n  }\n  handleNewFile(file) {\n    if (file.type.split('/')[0] != \"image\") {\n      return;\n    }\n    var reader = new FileReader();\n    reader.onload = readerLoadEvent => {\n      var img = new Image();\n      img.onload = () => {\n        this.canvas.width = img.width;\n        this.canvas.height = img.height;\n        if (this.preventUndersized && (img.width < this.width || img.height < this.height)) {\n          this.imageTooSmallModal.show();\n          return;\n        }\n        var ctx = this.canvas.getContext(\"2d\");\n        ctx.drawImage(img, 0, 0);\n        this.setView(\"hasPictureView\");\n        this.setImage();\n      };\n      img.src = readerLoadEvent.target.result.toString();\n    };\n    reader.readAsDataURL(file);\n  }\n  emitImage() {\n    var x = this.crop.offsetLeft / this.image.width * this.image.naturalWidth;\n    var y = this.crop.offsetTop / this.image.height * this.image.naturalHeight;\n    var cropRect = this.crop.getBoundingClientRect();\n    var width = cropRect.width / this.image.width * this.image.naturalWidth;\n    var height = cropRect.height / this.image.height * this.image.naturalHeight;\n    if (x < 0)\n      x = 0;\n    if (x > this.image.naturalWidth)\n      x = this.image.naturalWidth;\n    if (y < 0)\n      y = 0;\n    if (y > this.image.naturalWidth)\n      y = this.image.naturalWidth;\n    if (width > this.image.naturalWidth)\n      width = this.image.naturalWidth;\n    if (height > this.image.naturalHeight)\n      height = this.image.naturalHeight;\n    var dataUrl = this.generateCroppedImage(x, y, width, height, this.width, this.height);\n    this.imageCropChanged.emit(dataUrl);\n  }\n  generateCroppedImage(x, y, width, height, desiredWidth, desiredHeight) {\n    this.canvas.width = desiredWidth;\n    this.canvas.height = desiredHeight;\n    const context = this.canvas.getContext(\"2d\");\n    context.clearRect(0, 0, desiredWidth, desiredHeight);\n    context.drawImage(this.image, x, y, width, height, 0, 0, desiredWidth, desiredHeight);\n    return this.canvas.toDataURL(\"image/jpeg\", this.quality);\n  }\n  getCornerLeftTop(corner) {\n    let left = 0;\n    let top = 0;\n    switch (corner) {\n      case CornerType.se:\n        left = this.crop.offsetLeft;\n        top = this.crop.offsetTop;\n        break;\n      case CornerType.sw:\n        top = this.crop.offsetTop;\n        break;\n      default:\n        break;\n    }\n    return { top, left };\n  }\n  isMouseStillInTarget(event) {\n    var inside = false;\n    let mouseX;\n    let mouseY;\n    const imageRect = this.image.getBoundingClientRect();\n    if (event instanceof MouseEvent) {\n      mouseX = event.clientX;\n      mouseY = event.clientY;\n    }\n    if (typeof TouchEvent !== \"undefined\") {\n      if (event instanceof TouchEvent) {\n        var touch = event.touches[0];\n        mouseX = touch.clientX;\n        mouseY = touch.clientY;\n      }\n    }\n    if (mouseX >= imageRect.x &&\n      mouseY >= imageRect.y &&\n      mouseX <= imageRect.left + imageRect.width &&\n      mouseY <= imageRect.top + imageRect.height) {\n      inside = true;\n    }\n    var corners = this.crop.querySelectorAll(\"div\");\n    corners.forEach(corner => {\n      var cornerRect = corner.getBoundingClientRect();\n      if (mouseX >= cornerRect.x &&\n        mouseY >= cornerRect.y &&\n        mouseX <= cornerRect.left + cornerRect.width &&\n        mouseY <= cornerRect.top + cornerRect.height) {\n        inside = true;\n      }\n    });\n    return inside;\n  }\n  render() {\n    return (h(Host, { ref: el => this.host = el }, h(\"canvas\", { ref: el => this.canvas = el }), h(\"div\", { class: \"view\", ref: el => this.hasPictureView = el }, h(\"div\", { class: \"cropper\" }, h(\"img\", { ref: el => this.image = el }), h(\"div\", { class: \"backdrop\" }), h(\"div\", { class: \"crop\", ref: e => this.crop = e, onMouseDown: this.handleCropMouseDown, onTouchStart: this.handleCropMouseDown }, h(\"div\", { class: \"nw\" }), h(\"div\", { class: \"ne\" }), h(\"div\", { class: \"se\" }), h(\"div\", { class: \"sw\" })))), h(\"div\", { class: \"view\", ref: el => this.noPictureView = el }, h(\"dnn-dropzone\", { allowCameraMode: true, onFilesSelected: e => this.handleNewFile(e.detail[0]), resx: {\n        capture: this.resx.capture,\n        dragAndDropFile: this.resx.dragAndDropFile,\n        or: this.resx.or,\n        takePicture: this.resx.takePicture,\n        uploadFile: this.resx.uploadFile,\n      } })), h(\"dnn-modal\", { ref: el => this.imageTooSmallModal = el, \"close-text\": this.resx.modalCloseText }, h(\"p\", null, this.resx.imageTooSmall.replace(\"{width}\", this.width.toString()).replace(\"{height}\", this.height.toString())))));\n  }\n  static get is() { return \"dnn-image-cropper\"; }\n  static get encapsulation() { return \"shadow\"; }\n  static get originalStyleUrls() {\n    return {\n      \"$\": [\"dnn-image-cropper.scss\"]\n    };\n  }\n  static get styleUrls() {\n    return {\n      \"$\": [\"dnn-image-cropper.css\"]\n    };\n  }\n  static get properties() {\n    return {\n      \"width\": {\n        \"type\": \"number\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"number\",\n          \"resolved\": \"number\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Sets the desired final image width.\"\n        },\n        \"attribute\": \"width\",\n        \"reflect\": false,\n        \"defaultValue\": \"600\"\n      },\n      \"height\": {\n        \"type\": \"number\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"number\",\n          \"resolved\": \"number\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Sets the desired final image height.\"\n        },\n        \"attribute\": \"height\",\n        \"reflect\": false,\n        \"defaultValue\": \"600\"\n      },\n      \"resx\": {\n        \"type\": \"unknown\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"{\\n    capture: string;\\n    dragAndDropFile: string;\\n    or: string;\\n    takePicture: string;\\n    uploadFile: string;\\n    imageTooSmall: string;\\n    modalCloseText: string;\\n  }\",\n          \"resolved\": \"{ capture: string; dragAndDropFile: string; or: string; takePicture: string; uploadFile: string; imageTooSmall: string; modalCloseText: string; }\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Can be used to customize controls text.\\nSome values support tokens, see default values for examples.\"\n        },\n        \"defaultValue\": \"{\\n    capture: \\\"Capture\\\",\\n    dragAndDropFile: \\\"Drag and drop an image\\\",\\n    or: \\\"or\\\",\\n    takePicture: \\\"Take a picture\\\",\\n    uploadFile: \\\"Upload an image\\\",\\n    imageTooSmall: \\\"The image you are attempting to upload does not meet the minimum size requirement of {width} pixels by {height} pixels. Please upload a larger image.\\\",\\n    modalCloseText: \\\"Close\\\",\\n  }\"\n      },\n      \"quality\": {\n        \"type\": \"number\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"number\",\n          \"resolved\": \"number\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Sets the output quality of the corpped image (number between 0 and 1).\"\n        },\n        \"attribute\": \"quality\",\n        \"reflect\": false,\n        \"defaultValue\": \"0.8\"\n      },\n      \"preventUndersized\": {\n        \"type\": \"boolean\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"When set to true, prevents cropping an image smaller than the required size, which would blow pixel and make the final picture look blurry.\"\n        },\n        \"attribute\": \"prevent-undersized\",\n        \"reflect\": false,\n        \"defaultValue\": \"false\"\n      }\n    };\n  }\n  static get states() {\n    return {\n      \"view\": {}\n    };\n  }\n  static get events() {\n    return [{\n        \"method\": \"imageCropChanged\",\n        \"name\": \"imageCropChanged\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"When the image crop changes, emits the dataurl for the new cropped image.\"\n        },\n        \"complexType\": {\n          \"original\": \"string\",\n          \"resolved\": \"string\",\n          \"references\": {}\n        }\n      }];\n  }\n}\n//# sourceMappingURL=dnn-image-cropper.js.map\n"]}